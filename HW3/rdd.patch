--- rdd.c	2016-11-14 21:10:44.107072958 -0800
@@ -1,247 +0,0 @@
-/*
- *	CS 444 HW 3 - Encrypted Block Device	
- *	By Jonathan and Kyle
- *	Method: Pair Programming
- *
- *	Sources: 
- *	crypto/tcrypt.c
- *	http://kernel.readthedocs.io/en/sphinx-samples/crypto-API.html?highlight=crypto_cipher_setkey#introduction
- *	http://lxr.free-electrons.com/source/include/linux/crypto.h 
- *	http://lxr.free-electrons.com/source/Documentation/crypto/api-intro.txt
- *	
- *	Skeleton code from http://blog.superpat.com/2010/05/04/a-simple-block-driver-for-linux-kernel-2-6-31/
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
-
-#include <linux/kernel.h> /* printk() */
-#include <linux/fs.h>     /* everything... */
-#include <linux/errno.h>  /* error codes */
-#include <linux/types.h>  /* size_t */
-#include <linux/vmalloc.h>
-#include <linux/genhd.h>
-#include <linux/blkdev.h>
-#include <linux/hdreg.h>
-
-// JOHN-KYLE CODE
-#include <linux/crypto.h>
-
-MODULE_LICENSE("Dual BSD/GPL");
-static char *Version = "1.4";
-
-// JOHN-KYLE CODE
-struct crypto_cipher *tfm;
-int i;
-static char *charkey = "harambes";
-static int key_length = 8;
-module_param(charkey, charp, 0644);
-
-static int major_num = 0;
-module_param(major_num, int, 0);
-static int logical_block_size = 512;
-module_param(logical_block_size, int, 0);
-static int nsectors = 1024; /* How big the drive is */
-module_param(nsectors, int, 0);
-
-/*
- * We can tweak our hardware sector size, but the kernel talks to us
- * in terms of small sectors, always.
- */
-#define KERNEL_SECTOR_SIZE 512
-
-/*
- * Our request queue.
- */
-static struct request_queue *Queue;
-
-/*
- * The internal representation of our device.
- */
-static struct sbd_device {
-	unsigned long size;
-	spinlock_t lock;
-	u8 *data;
-	struct gendisk *gd;
-} Device;
-
-/*
- * Handle an I/O request.
- */
-static void sbd_transfer(struct sbd_device *dev, sector_t sector,
-		unsigned long nsect, char *buffer, int write) {
-	unsigned long offset = sector * logical_block_size;
-	unsigned long nbytes = nsect * logical_block_size;
-
-	// JOHN-KYLE CODE
-	u8 *source;
-	u8 *destination;
-//	u8 *dest2 = vmalloc(dev->size);
-//	u8 *src2;
-	unsigned int perBlock = crypto_cipher_blocksize(tfm);
-	crypto_cipher_setkey(tfm, charkey, key_length);
-
-	if ((offset + nbytes) > dev->size) {
-		printk (KERN_NOTICE "sbd: Beyond-end write (%ld %ld)\n", offset, nbytes);
-		return;
-	}
-	if (write){
-		// JOHN-KYLE CODE
-		source = buffer;
-		destination = dev->data + offset;
-	
-		printk("\n [WRITE] Decrypted (ORIGINAL) Data:\n");
-		for(i = 0; i < nbytes; i++){
-			printk("%02x", (unsigned char)*source++);
-		}
-		for(i = 0; i < nbytes; i += perBlock){
-			crypto_cipher_encrypt_one(tfm, destination + i, source + i);
-//			crypto_cipher_decrypt_one(tfm, dest2+i, destination + i);
-		}
-		printk("\n [WRITE] Encrypted Data:\n");
-		for(i = 0; i < nbytes; i++){
-			printk("%02x", (unsigned char)*destination++);
-		}	
-//		printk("\n [WRITE] Decrypted (Literally Decrypted) Data:\n");
-//		for(i = 0; i < nbytes; i++){
-//			printk("%02x", (unsigned char)*dest2++);
-//		}
-
-
-	}
-	
-	else{
-		source = dev->data + offset;
-		destination = buffer;
-
-		printk("\n [READ] Encrypted (ORIGINAL) Data:\n");
-		for(i = 0; i < nbytes; i++){
-			printk("%02x", (unsigned char)*source++);
-		}
-		for(i = 0; i < nbytes; i += perBlock){
-			crypto_cipher_decrypt_one(tfm, destination + i, source + i);
-//fix here kernel null pointer dereference eip EIP: 0060:[<c1344ffc>] EFLAGS: 00010002 CPU: 0
-//EIP is at aes_encrypt+0xd1c/0xd50
-//			crypto_cipher_encrypt_one(tfm, dest2 +i, destination + i);
-		}
-		printk("\n [READ] Decrypted Data:\n");
-		for(i = 0; i < nbytes; i++){
-			printk("%02x", (unsigned char)*destination++);
-		}
-//		printk("\n [READ] Rencrypted (Based on decrypted data. Should match above Encrypted.) Data:\n");
-//		for(i = 0; i < nbytes; i++){
-//			printk("%02x", (unsigned char)*dest2++);
-// 		}
-	}
-}
-
-static void sbd_request(struct request_queue *q) {
-	struct request *req;
-
-	req = blk_fetch_request(q);
-	while (req != NULL) {
-		// blk_fs_request() was removed in 2.6.36 - many thanks to
-		// Christian Paro for the heads up and fix...
-		//if (!blk_fs_request(req)) {
-		if (req == NULL || (req->cmd_type != REQ_TYPE_FS)) {
-			printk (KERN_NOTICE "Skip non-CMD request\n");
-			__blk_end_request_all(req, -EIO);
-			continue;
-		}
-		sbd_transfer(&Device, blk_rq_pos(req), blk_rq_cur_sectors(req),
-				req->buffer, rq_data_dir(req));
-		if ( ! __blk_end_request_cur(req, 0) ) {
-			req = blk_fetch_request(q);
-		}
-	}
-}
-
-/*
- * The HDIO_GETGEO ioctl is handled in blkdev_ioctl(), which
- * calls this. We need to implement getgeo, since we can't
- * use tools such as fdisk to partition the drive otherwise.
- */
-int sbd_getgeo(struct block_device * block_device, struct hd_geometry * geo) {
-	long size;
-
-	/* We have no real geometry, of course, so make something up. */
-	size = Device.size * (logical_block_size / KERNEL_SECTOR_SIZE);
-	geo->cylinders = (size & ~0x3f) >> 6;
-	geo->heads = 4;
-	geo->sectors = 16;
-	geo->start = 0;
-	return 0;
-}
-
-/*
- * The device operations structure.
- */
-static struct block_device_operations sbd_ops = {
-		.owner  = THIS_MODULE,
-		.getgeo = sbd_getgeo
-};
-
-static int __init sbd_init(void) {
-
-	tfm = crypto_alloc_cipher("aes", 4, CRYPTO_ALG_ASYNC);
-	/*
-	 * Set up our internal device.
-	 */
-	Device.size = nsectors * logical_block_size;
-	spin_lock_init(&Device.lock);
-	Device.data = vmalloc(Device.size);
-	if (Device.data == NULL)
-		return -ENOMEM;
-	/*
-	 * Get a request queue.
-	 */
-	Queue = blk_init_queue(sbd_request, &Device.lock);
-	if (Queue == NULL)
-		goto out;
-	blk_queue_logical_block_size(Queue, logical_block_size);
-	/*
-	 * Get registered.
-	 */
-	major_num = register_blkdev(major_num, "sbd");
-	if (major_num < 0) {
-		printk(KERN_WARNING "sbd: unable to get major number\n");
-		goto out;
-	}
-	/*
-	 * And the gendisk structure.
-	 */
-	Device.gd = alloc_disk(16);
-	if (!Device.gd)
-		goto out_unregister;
-	Device.gd->major = major_num;
-	Device.gd->first_minor = 0;
-	Device.gd->fops = &sbd_ops;
-	Device.gd->private_data = &Device;
-	strcpy(Device.gd->disk_name, "sbd0");
-	set_capacity(Device.gd, nsectors);
-	Device.gd->queue = Queue;
-	add_disk(Device.gd);
-
-	return 0;
-
-out_unregister:
-	unregister_blkdev(major_num, "sbd");
-out:
-	vfree(Device.data);
-	return -ENOMEM;
-}
-
-static void __exit sbd_exit(void)
-{
-	// JOHN-KYLE CODE
-	crypto_free_cipher(tfm);
-	del_gendisk(Device.gd);
-	put_disk(Device.gd);
-	unregister_blkdev(major_num, "sbd");
-	blk_cleanup_queue(Queue);
-	vfree(Device.data);
-}
-
-module_init(sbd_init);
-module_exit(sbd_exit);
--- KconfigO	2016-11-14 21:12:36.938948045 -0800
+++ Kconfig	2016-11-14 21:06:46.234119688 -0800
@@ -41,6 +41,11 @@
 	tristate "Atari floppy support"
 	depends on ATARI
 
+config RDD
+	tristate "John & Kyle RAM Disk Driver"
+	---help---
+		This is our third homework assignment configuration.
+
 config MAC_FLOPPY
 	tristate "Support for PowerMac floppy"
 	depends on PPC_PMAC && !PPC_PMAC64
--- MakefileO	2016-11-14 21:13:03.772393966 -0800
+++ Makefile	2016-11-14 21:12:42.764044848 -0800
@@ -33,6 +33,7 @@
 
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
 obj-$(CONFIG_BLK_DEV_HD)	+= hd.o
+obj-m 		+= rdd.o
 
 obj-$(CONFIG_XEN_BLKDEV_FRONTEND)	+= xen-blkfront.o
 obj-$(CONFIG_XEN_BLKDEV_BACKEND)	+= xen-blkback/
